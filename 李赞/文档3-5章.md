## 3 数据包格式和转发

* 统一的数据包格式，促进可扩展性，承载不同“类型”的信息
* 嵌入到UDP datagram中
* 消息共享一个通用的头格式，让节点正确接受和重传未知类型的消息
* 消息可以洪泛到整个网络上，也可以被限制在一定直径内
* 当洪泛任何控制消息时，将在本地消除重复的重传（每个节点维护一个重复集，并使用MPRs）
* 节点可以检查消息的包头，来获得消息发起方的距离的信息

### 3.1 协议和端口号

协议：UDP

端口号：698（OLSR专用）

### 3.2 主地址

对拥有一个接口的节点，主地址必须是这个接口的地址

### 3.3 数据包格式

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Packet Length         |    Packet Sequence Number     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Message Type |     Vtime     |         Message Size          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      Originator Address                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Time To Live |   Hop Count   |    Message Sequence Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      :                            MESSAGE                            :
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Message Type |     Vtime     |         Message Size          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      Originator Address                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Time To Live |   Hop Count   |    Message Sequence Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      :                            MESSAGE                            :
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                                                               :
               (etc.)
#### 3.3.1 数据包头

* Packet Length
* Packet Sequence Number

每次传输新的OLSR数据包时，数据包序列号（PSN）必须增加一个。”Wrap-around”按第19节所述处理。为每个接口维护单独的分组序列号，以便按顺序枚举通过接口传输的分组。

通过其传输数据包的接口的IP地址可以从数据包的IP报头获得。如果数据包不包含任何消息（即，数据包长度小于或等于数据包头的大小），则必须静默地丢弃该数据包。对于IPv4地址，这意味着必须丢弃数据包长度<16的数据包。

#### 3.3.2 消息头

* 消息类型
  此字段指示要在“消息”部分找到的消息类型。0-127范围内的消息类型保留给本文档中的消息和可能的扩展名。
* 时间
  此字段指示节点在接收到消息后必须将消息中包含的信息视为有效的时间，除非接收到对该信息的最新更新。有效时间用尾数（Vtime字段的四个最高位）和指数（Vtime字段的四个最低位）表示。换言之：
  有效时间=C*（1+a/16）*2^b[秒]，
  其中a是由Vtime字段的四个最高位表示的整数，b是由Vtime字段的四个最低位表示的整数。比例因子C的建议值在第18节中规定。
* 消息大小
  这将给出此消息的大小，以字节为单位，从“消息类型”字段的开头到下一个“消息类型”字段的开头（或者如果没有后续消息，则为数据包的结尾）测量。
* 发起人地址
  此字段包含最初生成此消息的节点的主地址。不应将此字段与来自IP报头的源地址混淆，IP报头每次都更改为正在重新传输此消息的中间接口的地址。发端人地址字段在重新传输时必须*永不*更改。
* TTL
  此字段包含将发送消息的最大跳数。在重新传输消息之前，生存时间必须减少1。当节点接收到生存时间等于0或1的消息时，在任何情况下都不得重新传输该消息。通常，节点不会接收TTL为零的消息。因此，通过设置此字段，消息的发起方可以限制泛洪半径。
* 跳数
    此字段包含消息已达到的跃点数。在重新传输消息之前，跃点计数必须增加1。最初，邮件的发起人将其设置为“0”。
* 消息序列号
    生成消息时，“发端人”节点将为每个消息分配一个唯一的标识号。此号码将插入到消息的序列号字段中。对于来自节点的每条消息，序列号将增加1。”Wrap-around"按第19节所述处理。消息序列号用于确保给定消息不会被任何节点重新传输多次

### 3.4 包处理和消息泛洪

在接收到基本包时，节点检查每个“消息头”。根据“消息类型”字段的值，节点可以确定消息的命运。一个节点可能多次收到同一消息。因此，为了避免对已经接收和处理的一些消息进行重新处理，每个节点维护一个重复的集合。在该集合中，节点记录关于最近接收到的消息的信息，其中避免重复处理消息。对于这样的消息，一个节点记录一个“重复元组” (D_addr, D_seq_num, D_retransmitted, D_iface_list,    D_time)，其中D_addr是消息的发起地址，D_seq_num是消息的消息序列号，D_retransmitted是一个布尔值，指示消息是否已经被重传，D_iface_list是一个接收到消息的接口地址列表,D_time指定元组过期且*必须*被删除的时间。在节点中，重复元组的集合被表示为“重复集”。

在本节中，术语“发起人地址”将用于发送消息的节点的主地址。术语“发送者接口地址”将用于发送消息的接口的发送者地址（在包含消息的数据包的IP报头中给出）。术语“接收接口地址”将用于接收消息的节点的接口地址。因此，在接收到基本分组时，节点必须对每个封装的消息执行以下任务：

1. 如果分组不包含消息（即，分组长度小于或等于分组报头的大小），则必须静默地丢弃该分组。对于IPv4地址，这意味着必须静默地丢弃数据包，其中数据包长度<16。

2. 如果消息的生存时间小于或等于“0”（零），或者消息是由接收节点发送的（即，消息的发起地址是接收节点的主地址），则必须静默地丢弃消息。

3. 处理条件：

* 如果在重复集中存在元组，其中：

   ```
   D_addr=＝Originator Address
   
   AND
   
   D_seq_num=＝Message Sequence Number
   ```

   则消息已经被完全处理，并且不能再次处理。

* 否则，如果节点实现了该消息的消息类型，则必须按照该消息类型的规范处理该消息。

4. 转发条件：

* 重复集中有这样的元组：

```
D_addr=＝Originator Address

AND

D_seq_num=＝Message Sequence Number

AND

接收端口（地址）在D_iface_list中
```

则这条消息就被转发，不应再次重新传输

* 否则：
  * 如果节点执行消息的Message Type字段，则必须根据消息类型的规范考虑转发该消息
  * 否则，如果节点没有执行消息的Message Type字段，则应按照下面描述的默认转发算法处理消息

#### 3.4.1 默认转发算法

默认转发算法如下：

1. 如果未检测到消息的发送方接口地址位于节点的对称1跳邻域中，则转发算法必须在此处静默停止（并且消息不得被转发）。

2. ```
           D_retransmitted is false, 
           AND
接收到的接口消息（的地址）不包含在D_iface_list中
       ```
```
           
3. 否则，如果不存在这样的条目，则进一步考虑消息转发。如果在这些步骤之后，不考虑转发消息，则停止处理此部分（即忽略步骤4到8），否则，如果仍考虑转发，则使用以下算法：

4. 如果发送方接口地址是此节点的MPR选择器的接口地址，并且如果消息的生存时间大于“1”，则必须重新传输消息（如后面步骤6到8中所述）。

5. 如果复制集中存在一个条目，具有相同的发件人地址和相同的消息序列号，则条目更新如下：

```
      D_time    = current time + DUP_HOLD_TIME.
      
      接收接口（的地址）被添加到数据接口列表中。
      
      当且仅当根据步骤4重传消息时，D_retransmitted设置为true。
      ```
    
      否则，重复集合中的条目记录为：
    
                     D_addr    = Originator Address
          
                     D_seq_num = Message Sequence Number
          
                     D_time    = current time + DUP_HOLD_TIME.
          
                     D_iface_list contains the receiving interface address.
          
                     D_retransmitted is set to true if and only if the message will be retransmitted according to step 4.
      如果且仅当根据步骤4，必须重新传输消息时：

6. 消息的TTL减少1。

7. 消息的跃点计数增加1

8. 消息在所有接口上广播（注意：消息头的其余字段应保持不变）

#### 3.4.2 关于处理转发的思考

应该注意的是，处理和转发消息是两种不同的操作，受不同规则的约束。处理涉及到使用消息的内容，而转发涉及到为网络的其他节点重新发送相同的消息。注意，此规范包括对每个已知消息类型的转发和处理的描述。具有已知消息类型的消息必须*不*被此算法“盲目”转发。转发（并在转发的已知消息中设置正确的消息头）是算法的责任，该算法指定如何处理消息，并在必要时重新传输。这使得可以指定消息类型字段，以便在传输过程中可以修改消息（例如，反映消息所走的路由）。它还允许绕过MPR洪泛机制，如果由于某种原因需要消息类型的经典洪泛，则算法指定应如何处理此类消息，将简单地重新广播消息，而不考虑MPR。通过定义一组必须由OLSR的所有实现识别的消息类型，可以通过引入其他消息类型来扩展协议，同时仍然能够保持与旧实现的兼容性。OLSR核心功能所需的消息类型有：

-HELLO消息，执行链路感知、邻居检测和MPR信令任务，

-TC消息，执行拓扑声明（链路状态公告）任务。

-MID消息，执行声明节点上存在多个接口的任务。

其他消息类型包括后面章节中指定的类型，以及未来可能的扩展，例如启用节能/休眠模式的消息、多播路由、对单向链接的支持、自动配置/地址分配等。

### 3.5 消息发射和抖动

3.5条。消息发射和抖动
作为一个基本的实现要求，应该避免控制消息的同步。因此，应该发出OLSR控制消息，以避免同步。由于各种原因（主要是与分组处理的定时器交互），来自相邻节点的控制业务的发射可能变得同步，使得多个相邻节点尝试同时发送控制业务。根据底层链路层的性质，这可能会导致或可能不会导致冲突，从而导致消息丢失-可能会丢失同一类型的几个后续消息。为了避免这种同步，提出了以下简单的发送控制消息的策略。节点应该在生成消息的时间间隔中添加一定数量的抖动。抖动必须是生成的每条消息的随机值。因此，对于使用抖动的节点：

实际消息间隔=消息间隔-抖动

其中抖动是一个值，从间隔[0，MAXJITTER]中随机选择，并且消息间隔是为发出的消息指定的消息间隔的值（例如，HELLO消息的HELLO间隔，TC_TC消息的间隔等）。转发邮件时也应引入抖动。可以采用以下简单的策略：当消息要由节点转发时，它应该在短时间内保持在节点中：

保持消息周期=抖动

其中抖动是[0，MAXJITTER]中的随机值。

注意，当节点发送控制消息时，可以利用携带其他消息的机会（在其保持期到期之前）来减少分组传输的次数。注意，控制消息的最小速率是强制的。如果有利于特定部署，则节点可以以更高的速率发送控制消息。

## 4 信息库

通过OLSR控制消息的交换，每个节点积累有关网络的信息。根据本节中的说明存储此信息

### 4.1 多接口关联信息库

对于网络中的每个目的地，记录“接口关联元组”

 (I_iface_addr, I_main_addr, I_time) 

I_iface_addr是节点的接口地址，I_main_addr是该节点的主地址。I_time指定此元组过期且*必须*移除的时间。在节点中，接口关联元组的集合被表示为“接口关联集”。

### 4.2 链路感知：本地链路信息库

本地链接信息库存储有关到邻居的链接的信息。

#### 4.2.1 链接集

一个节点记录一组“链路元组”

(L_local_iface_addr,    L_neighbor_iface_addr, L_SYM_time, L_ASYM_time, L_time).

L_local_iface_addr是本地节点的接口地址（即链路的一个端点），L_neighbor_iface_addr是邻居节点的接口地址（即链路的另一个端点），L_SYM_time是链路被认为是对称的时间，

L_ASYM_time是听到邻居接口的时间，

L_time指定此记录过期且*必须*删除的时间。当L_SYM_time和L_ASYM_time过期时，该链接将被视为丢失

在HELLO消息中声明邻居接口时使用此信息。L_SYM_time用于确定为邻居接口声明的链接类型。如果L_SYM_time未过期，则必须将链接声明为对称。如果L_SYM_time过期，则必须将链接声明为非对称。如果L_SYM_time和L_ASYM_time都已过期，则必须声明链接丢失。

在节点中，链接元组的集合被表示为“链接集”。

### 4.3 邻域检测：邻域信息库

邻域信息库存储关于邻居、2跳邻居、MPR和MPR选择器的信息

#### 4.3.1 邻居集

节点记录一组描述邻居的“邻居元组”

（N_neighbor_main_addr，N_status，N_willity）。N_neighbor_main_addr是邻居的主地址，N_status指定节点是NOT_SYM或SYM。N_willingness为0到7之间的整数，并指定节点代表其他节点承载流量的意愿。

#### 4.3.2 2跳邻居集

节点记录一组“2跳元组”

(N_neighbor_main_addr,    N_2hop_addr, N_time)

描述其邻居和对称2-hop邻域之间的对称（并且，由于定义上的MPR链路也是对称的，因此也是MPR）链路。N_neighbor_main_addr是邻居的主地址，N_2hop_addr是具有到N_neighbor_main_addr的对称链接的2跳邻居的主地址，N_time指定元组过期且*必须*删除的时间。在节点中，2跳元组的集合被表示为“2跳邻居集”。

#### 4.3.3 MPR集

一个节点维护一组被选为MPR的邻居。它们的主要地址列在MPR集合中。

#### 4.3.4 MPR选择器集

一个节点记录一组MPR选择器元组（MS_main_addr，MS_time），描述选择该节点作为MPR的邻居。MS_main_addr是节点的主地址，该节点已选择此节点作为MPR。MS_time指定元组过期且*必须*移除的时间。在节点中，MPR选择器元组的集合被表示为“MPR选择器集”。

### 4.4 拓扑信息库

网络中的每个节点维护有关网络的拓扑信息。此信息从TC消息获取，用于路由表计算。因此，对于网络中的每个目的地，至少记录一个“拓扑元组”（T_dest_addr、T_last_addr、T_seq、T_time）。T_dest_addr是节点的主地址，可以从主地址T_last_addr的节点一跳到达。通常，T_last_addr是T_dest_addr的MPR。T_seq是一个序列号，T_time指定此元组过期且*必须*移除的时间。在节点中，拓扑元组的集合被表示为“拓扑集”。

## 5 主地址和多接口

对于单个OLSR接口节点，OLSR接口地址与相应的主地址之间的关系很小：主地址是OLSR接口地址。对于多个OLSR接口节点，通过交换多个接口声明（MID）消息来定义OLSR接口地址和主地址之间的关系。本节描述如何交换和处理中间消息。具有多个接口的每个节点必须定期向网络中的其他节点公布描述其接口配置的信息。这是通过通过MPR洪泛机制将多接口声明消息洪泛到网络中的所有节点来实现的。网络中的每个节点维护关于网络中其他节点的接口信息。该信息从多个参与MANET接口的节点发出的MID消息中获取，用于路由表计算。具体来说，多接口声明通过在每个节点中填充多接口关联库，将多个接口关联到节点（及主地址）。

### 5.1 MID Message 格式

MID消息的拟议格式如下：

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    OLSR Interface Address                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    OLSR Interface Address                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ...                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
它作为第3.4节中描述的通用分组格式的数据部分发送，“消息类型”设置为MID_消息。应该将生存时间设置为255（最大值），以将消息扩散到整个网络中，并将VTIME相应地设置为MIDI HOLD时间的值，如第18.3节所述。OLSR接口地址此字段包含节点的OLSR接口的地址，不包括节点主地址（已在发起人地址中指明）。除了发端节点的主地址之外，所有接口地址都放在中间消息中。如果达到最大允许的消息大小（由网络强加），而仍然没有插入到中间消息的接口地址，则生成更多的中间消息，直到已经发送了整个接口地址集。

### 5.2 MID消息生成

MID消息由网络中的节点发送以声明其多个接口（如果有的话）。即，MID消息包含与其主地址相关联的接口地址列表。地址列表可以在每个MID消息中是部分的（例如，由于网络施加的消息大小限制），但是描述节点接口集的所有MID消息的解析必须在某个刷新周期（MID_INTERVAL）内完成。这些中间消息在网络中传播的信息将帮助每个节点计算其路由表。只有一个接口地址参与MANET的节点（即运行OLSR）不能生成任何MID消息。具有多个接口的节点，其中只有一个参与MANET并运行OLSR（例如，节点连接到有线网络以及MANET）不得生成任何中间消息。具有多个接口的节点（其中多个节点参与MANET并运行OLSR）必须按指定生成MID消息。

### 5.3 MID消息转发

MID消息由mpr广播和重传，以便在整个网络中传播消息。必须使用“默认转发算法”（如第3.4节所述）转发MID消息。

### 5.4 MID消息处理

多接口关联集中的元组记录有通过中间消息交换的信息。收到MID消息后，必须从消息头的Vtime字段计算“有效时间”（如第3.3.2节所述）。然后应更新多接口关联信息库，如下所示：

1. 如果此消息的发送方接口（NB:not originator）不在此节点的对称1跳邻居中，则必须丢弃此消息。
2. 在MID消息中列出的每个接口地址：
* 如果在接口关联集中存在一些元组，其中：

                                  I_iface_addr == interface address, AND
        
                                   I_main_addr  == originator address,
        
                              then the holding time of that tuple is set to:
        
                                   I_time       = current time + validity time.

* 否则新元组记录在接口关联集中，其中：

                    I_iface_addr = interface address,
    
                    I_main_addr  = originator address,
                    
                    I_time       = current time + validity time.
### 5.5 从接口地址解析主地址

一般来说，OLSR中唯一需要使用“接口地址”的部分是链路感知。OLSR的其余部分在节点上操作，由其“主地址”唯一标识（实际上，节点的主地址是其“节点id”-为了方便起见，它对应于其一个接口的地址）。在只有单个接口节点的网络中，根据定义，节点的主地址将等于节点的接口地址。在一个公共OLSR区域内有多个接口节点的网络中，需要能够将任何接口地址映射到相应的主地址。MID消息的交换提供了一种由网络中的节点获取接口信息的方法。这允许在给定一个节点接口地址的情况下识别该节点的“主地址”。

给定接口地址：

1. 如果在接口关联集中存在一些元组：

    I_iface_addr == interface address

   那么主地址搜索的结果是元组的originator:address I_main_addr

2. 否则，主地址搜索的结果是接口地址本身。